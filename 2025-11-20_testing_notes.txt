День полного цикла тестирования (юнит-тесты, структура, pytest)

Сегодня я прошёл полноценный цикл тестирования своих Python-проектов и впервые почувствовал себя не просто учеником, а настоящим будущим QA Automation / Python Engineer. С самого утра открыл свою рабочую папку python-mini-projects/apps/calculator_app и навёл порядок в структуре. Я понял важную вещь: pytest не «тестирует папки» — он вызывает тестовые функции в файлах test_*.py, а эти тестовые функции уже импортируют и проверяют мой реальный рабочий код. Благодаря этому я перестроил оба калькулятора так, как делается в реальных проектах.

Сначала я рефакторил calculator_simple.py и calculator_debug.py. Вынес бесконечные циклы с input() в отдельные функции (run_cli() и run_cli_debug()), а в конце файлов добавил защитную конструкцию if __name__ == "__main__":. Это позволяет импортировать модули в тестах без запуска консольного интерфейса. По сути, я впервые разделил «чистые функции» и «интерактивный слой» — как это делают инженеры, которые пишут код, пригодный для тестирования и CI/CD.

После подготовки исходников я создал полноценные тестовые файлы: test_calculator_simple.py, test_calculator_debug.py и отдельный smoke-тест. Я написал проверки для всех функций: add, subtract, multiply, divide, calculate, включая случаи с ошибками (деление на ноль, неизвестный оператор). Когда я запустил python -m pytest -vv и увидел строку 7 passed, я впервые получил ощущение правильной инженерной работы: код → тесты → проверка → результат.

Я разобрался, как запускать тесты по-разному: весь набор тестов, тесты в одной папке, один отдельный файл или даже одну конкретную тестовую функцию. Теперь я уверенно использую:

python -m pytest — базовый запуск

python -m pytest -vv — подробный режим

python -m pytest -s — показать все print()

python -m pytest file.py::test_name — запуск конкретного теста

Я понял, что означает каждый флаг:

-vv — подробный verbose-вывод, показывает каждый тест

-s — отключает захват вывода pytest и показывает реальные print()

-m — запуск тестов по маркировке (smoke, slow, regression)

Также я чётко разобрался, как работает ключевое слово assert в тестах. Это утверждение, которое должно быть истинным. Если результат функции не совпадает с ожидаемым, pytest автоматически поднимает AssertionError, и тест падает. Все тесты, которые я написал, теперь проверяют мою логику математических операций с максимальной точностью.

В процессе я проверил, что тесты действительно вызывают мой рабочий код: добавил временный print(">>> IMPORTED <<<") в calculator_simple.py и запускал pytest с -s. Это подтвердило, что тестовый файл импортирует именно мои функции, а не выполняет сам себя.

Также я разобрался, что при упаковке проекта в Docker тесты в контейнер не включаются. Внутрь пойдут только рабочие файлы:

calculator_simple.py  
calculator_debug.py  
api.py (который я буду создавать)  
requirements.txt  
Dockerfile  


А тесты останутся в репозитории — их запускает разработчик или CI, но не контейнер. Я также подготовил базу для следующего этапа — создания API с помощью FastAPI, чтобы тестировать работу калькулятора уже не через CLI, а через HTTP-запросы в Postman. Это будет полноценный шаг в сторону backend-инженерии и DevOps.

В итоге сегодня я впервые прошёл полный цикл: реорганизация кода → подготовка к тестированию → написание тестов → успешный запуск pytest → понимание структуры проекта → подготовка к Docker и Postman. Это тот тип работы, который уже делают junior automation engineers. Я почувствовал, что шаг за шагом выхожу на реальный уровень и готов двигаться дальше: API, Docker, Postman, CI/CD.